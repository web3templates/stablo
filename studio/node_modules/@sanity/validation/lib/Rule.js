"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

var _escapeRegex = _interopRequireDefault(require("./util/escapeRegex"));

var _convertToValidationMarker = _interopRequireDefault(require("./util/convertToValidationMarker"));

var _pathToString = _interopRequireDefault(require("./util/pathToString"));

var _genericValidator = _interopRequireDefault(require("./validators/genericValidator"));

var _booleanValidator = _interopRequireDefault(require("./validators/booleanValidator"));

var _numberValidator = _interopRequireDefault(require("./validators/numberValidator"));

var _stringValidator = _interopRequireDefault(require("./validators/stringValidator"));

var _arrayValidator = _interopRequireDefault(require("./validators/arrayValidator"));

var _objectValidator = _interopRequireDefault(require("./validators/objectValidator"));

var _dateValidator = _interopRequireDefault(require("./validators/dateValidator"));

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var typeValidators = {
  Boolean: _booleanValidator.default,
  Number: _numberValidator.default,
  String: _stringValidator.default,
  Array: _arrayValidator.default,
  Object: _objectValidator.default,
  Date: _dateValidator.default
};

var getBaseType = type => {
  return type && type.type ? getBaseType(type.type) : type;
};

var isFieldRef = constraint => {
  if (typeof constraint !== 'object' || !constraint) return false;
  return constraint.type === Rule.FIELD_REF;
};

var EMPTY_ARRAY = [];
var FIELD_REF = Symbol('FIELD_REF');
var ruleConstraintTypes = ['Array', 'Boolean', 'Date', 'Number', 'Object', 'String']; // Note: `RuleClass` and `Rule` are split to fit the current `@sanity/types`
// setup. Classes are a bit weird in the `@sanity/types` package because classes
// create an actual javascript class while simultaneously creating a type
// definition.
//
// This implicitly creates two types:
// 1. the instance type â€” `Rule` and
// 2. the static/class type - `RuleClass`
//
// The `RuleClass` type contains the static methods and the `Rule` instance
// contains the instance methods.
//
// This package exports the RuleClass as a value without implicitly exporting
// an instance definition. This should help reminder downstream users to import
// from the `@sanity/types` package.

var Rule = (_temp = _class = class Rule {
  constructor(typeDef) {
    _defineProperty(this, "_type", undefined);

    _defineProperty(this, "_level", undefined);

    _defineProperty(this, "_required", undefined);

    _defineProperty(this, "_typeDef", undefined);

    _defineProperty(this, "_message", undefined);

    _defineProperty(this, "_rules", []);

    _defineProperty(this, "_fieldRules", undefined);

    _defineProperty(this, "valueOfField", Rule.valueOfField.bind(Rule));

    this._typeDef = typeDef;
    this.reset();
  }

  _mergeRequired(next) {
    if (this._required === 'required' || next._required === 'required') return 'required';
    if (this._required === 'optional' || next._required === 'optional') return 'optional';
    return undefined;
  } // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class


  error(message) {
    var rule = this.clone();
    rule._level = 'error';
    rule._message = message || undefined;
    return rule;
  }

  warning(message) {
    var rule = this.clone();
    rule._level = 'warning';
    rule._message = message || undefined;
    return rule;
  }

  reset() {
    this._type = this._type || undefined;
    this._rules = (this._rules || []).filter(rule => rule.flag === 'type');
    this._message = undefined;
    this._required = undefined;
    this._level = 'error';
    this._fieldRules = undefined;
    return this;
  }

  isRequired() {
    return this._required === 'required';
  }

  clone() {
    var rule = new Rule();
    rule._type = this._type;
    rule._message = this._message;
    rule._required = this._required;
    rule._rules = (0, _cloneDeep2.default)(this._rules);
    rule._level = this._level;
    rule._fieldRules = this._fieldRules;
    rule._typeDef = this._typeDef;
    return rule;
  }

  cloneWithRules(rules) {
    var rule = this.clone();
    var newRules = new Set();
    rules.forEach(curr => {
      if (curr.flag === 'type') {
        rule._type = curr.constraint;
      }

      newRules.add(curr.flag);
    });
    rule._rules = rule._rules.filter(curr => {
      var disallowDuplicate = ['type', 'uri', 'email'].includes(curr.flag);
      var isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules);
    return rule;
  }

  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type) {
      throw new Error('merge() failed: conflicting types');
    }

    var newRule = this.cloneWithRules(rule._rules);
    newRule._type = this._type || rule._type;
    newRule._message = this._message || rule._message;
    newRule._required = this._mergeRequired(rule);
    newRule._level = this._level === 'error' ? rule._level : this._level;
    return newRule;
  } // Validation flag setters


  type(targetType) {
    var type = "".concat(targetType.slice(0, 1).toUpperCase()).concat(targetType.slice(1));

    if (!ruleConstraintTypes.includes(type)) {
      throw new Error("Unknown type \"".concat(targetType, "\""));
    }

    var rule = this.cloneWithRules([{
      flag: 'type',
      constraint: type
    }]);
    rule._type = type;
    return rule;
  }

  all(children) {
    return this.cloneWithRules([{
      flag: 'all',
      constraint: children
    }]);
  }

  either(children) {
    return this.cloneWithRules([{
      flag: 'either',
      constraint: children
    }]);
  } // Shared rules


  optional() {
    var rule = this.cloneWithRules([{
      flag: 'presence',
      constraint: 'optional'
    }]);
    rule._required = 'optional';
    return rule;
  }

  required() {
    var rule = this.cloneWithRules([{
      flag: 'presence',
      constraint: 'required'
    }]);
    rule._required = 'required';
    return rule;
  }

  custom(fn) {
    return this.cloneWithRules([{
      flag: 'custom',
      constraint: fn
    }]);
  }

  min(len) {
    return this.cloneWithRules([{
      flag: 'min',
      constraint: len
    }]);
  }

  max(len) {
    return this.cloneWithRules([{
      flag: 'max',
      constraint: len
    }]);
  }

  length(len) {
    return this.cloneWithRules([{
      flag: 'length',
      constraint: len
    }]);
  }

  valid(value) {
    var values = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{
      flag: 'valid',
      constraint: values
    }]);
  } // Numbers only


  integer() {
    return this.cloneWithRules([{
      flag: 'integer'
    }]);
  }

  precision(limit) {
    return this.cloneWithRules([{
      flag: 'precision',
      constraint: limit
    }]);
  }

  positive() {
    return this.cloneWithRules([{
      flag: 'min',
      constraint: 0
    }]);
  }

  negative() {
    return this.cloneWithRules([{
      flag: 'lessThan',
      constraint: 0
    }]);
  }

  greaterThan(num) {
    return this.cloneWithRules([{
      flag: 'greaterThan',
      constraint: num
    }]);
  }

  lessThan(num) {
    return this.cloneWithRules([{
      flag: 'lessThan',
      constraint: num
    }]);
  } // String only


  uppercase() {
    return this.cloneWithRules([{
      flag: 'stringCasing',
      constraint: 'uppercase'
    }]);
  }

  lowercase() {
    return this.cloneWithRules([{
      flag: 'stringCasing',
      constraint: 'lowercase'
    }]);
  }

  regex(pattern, a, b) {
    var _a$name, _a$invert;

    var name = typeof a === 'string' ? a : (_a$name = a === null || a === void 0 ? void 0 : a.name) !== null && _a$name !== void 0 ? _a$name : b === null || b === void 0 ? void 0 : b.name;
    var invert = typeof a === 'string' ? false : (_a$invert = a === null || a === void 0 ? void 0 : a.invert) !== null && _a$invert !== void 0 ? _a$invert : b === null || b === void 0 ? void 0 : b.invert;
    var constraint = {
      pattern,
      name,
      invert: invert || false
    };
    return this.cloneWithRules([{
      flag: 'regex',
      constraint
    }]);
  }

  email() {
    return this.cloneWithRules([{
      flag: 'email'
    }]);
  }

  uri(opts) {
    var optsScheme = (opts === null || opts === void 0 ? void 0 : opts.scheme) || ['http', 'https'];
    var schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];

    if (!schemes.length) {
      throw new Error('scheme must have at least 1 scheme specified');
    }

    var constraint = {
      options: {
        scheme: schemes.map(scheme => {
          if (!(scheme instanceof RegExp) && typeof scheme !== 'string') {
            throw new Error('scheme must be a RegExp or a String');
          }

          return typeof scheme === 'string' ? new RegExp("^".concat((0, _escapeRegex.default)(scheme), "$")) : scheme;
        }),
        allowRelative: (opts === null || opts === void 0 ? void 0 : opts.allowRelative) || false,
        relativeOnly: (opts === null || opts === void 0 ? void 0 : opts.relativeOnly) || false,
        allowCredentials: (opts === null || opts === void 0 ? void 0 : opts.allowCredentials) || false
      }
    };
    return this.cloneWithRules([{
      flag: 'uri',
      constraint
    }]);
  } // Array only


  unique() {
    return this.cloneWithRules([{
      flag: 'unique'
    }]);
  } // Objects only


  reference() {
    return this.cloneWithRules([{
      flag: 'reference'
    }]);
  }

  block(blockValidator) {
    return this.cloneWithRules([{
      flag: 'block',
      constraint: blockValidator
    }]);
  }

  fields(rules) {
    if (this._type !== 'Object') {
      throw new Error('fields() can only be called on an object type');
    }

    var rule = this.cloneWithRules([]);
    rule._fieldRules = rules;
    return rule;
  }

  assetRequired() {
    var base = getBaseType(this._typeDef);
    var assetType;

    if (base && ['image', 'file'].includes(base.name)) {
      assetType = base.name === 'image' ? 'Image' : 'File';
    } else {
      assetType = 'Asset';
    }

    return this.cloneWithRules([{
      flag: 'assetRequired',
      constraint: {
        assetType
      }
    }]);
  }

  validate(value) {
    var _arguments = arguments,
        _this = this;

    return _asyncToGenerator(function* () {
      var context = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
      var valueIsEmpty = value === null || value === undefined; // Short-circuit on optional, empty fields

      if (valueIsEmpty && _this._required === 'optional') {
        return EMPTY_ARRAY;
      }

      var rules = // Run only the _custom_ functions if the rule is not set to required or optional
      _this._required === undefined && valueIsEmpty ? _this._rules.filter(curr => curr.flag === 'custom') : _this._rules;
      var validators = _this._type && typeValidators[_this._type] || _genericValidator.default;
      var results = yield Promise.all(rules.map( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (curr) {
          if (curr.flag === undefined) {
            throw new Error('Invalid rule, did not contain "flag"-property');
          }

          var validator = validators[curr.flag];

          if (!validator) {
            var forType = _this._type ? "type \"".concat(_this._type, "\"") : 'rule without declared type';
            throw new Error("Validator for flag \"".concat(curr.flag, "\" not found for ").concat(forType));
          }

          var specConstraint = 'constraint' in curr ? curr.constraint : null;

          if (isFieldRef(specConstraint)) {
            specConstraint = (0, _get2.default)(context.parent, specConstraint.path);
          }

          var result;

          try {
            result = yield validator(specConstraint, value, _this._message, context);
          } catch (err) {
            var errorFromException = new _ValidationError.default("".concat((0, _pathToString.default)(context.path), ": Exception occurred while validating value: ").concat(err.message));
            return (0, _convertToValidationMarker.default)(errorFromException, 'error', context);
          }

          return (0, _convertToValidationMarker.default)(result, _this._level, context);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()));
      return results.flat();
    })();
  }

}, _defineProperty(_class, "FIELD_REF", FIELD_REF), _defineProperty(_class, "array", def => new _class(def).type('Array')), _defineProperty(_class, "object", def => new _class(def).type('Object')), _defineProperty(_class, "string", def => new _class(def).type('String')), _defineProperty(_class, "number", def => new _class(def).type('Number')), _defineProperty(_class, "boolean", def => new _class(def).type('Boolean')), _defineProperty(_class, "dateTime", def => new _class(def).type('Date')), _defineProperty(_class, "valueOfField", path => ({
  type: FIELD_REF,
  path
})), _temp);
var _default = Rule;
exports.default = _default;