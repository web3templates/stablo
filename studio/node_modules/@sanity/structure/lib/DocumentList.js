"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeNamesFromFilter = getTypeNamesFromFilter;
exports.DocumentListBuilder = void 0;

var _initialValueTemplates = require("@sanity/initial-value-templates");

var _Schema = require("./parts/Schema");

var _documentActionUtils = require("./parts/documentActionUtils");

var _Client = require("./parts/Client");

var _SerializeError = require("./SerializeError");

var _GenericList = require("./GenericList");

var _Document = require("./Document");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var resolveTypeForDocument = id => {
  var query = '*[_id in [$documentId, $draftId]]._type';
  var documentId = id.replace(/^drafts\./, '');
  var draftId = "drafts.".concat(documentId);
  return _Client.structureClient.fetch(query, {
    documentId,
    draftId
  }, {
    tag: 'structure.resolve-type'
  }).then(types => types[0]);
};

var validateFilter = (spec, options) => {
  var filter = spec.options.filter.trim();

  if (['*', '{'].includes(filter[0])) {
    throw new _SerializeError.SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(_SerializeError.HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }

  return filter;
};

var resolveDocumentChildForItem = (itemId, options) => {
  var parentItem = options.parent;
  var type = parentItem.schemaTypeName || resolveTypeForDocument(itemId);
  return Promise.resolve(type).then(schemaType => schemaType ? (0, _Document.getDefaultDocumentNode)({
    schemaType,
    documentId: itemId
  }) : new _Document.DocumentBuilder().id('editor').documentId(itemId).schemaType(''));
};

class DocumentListBuilder extends _GenericList.GenericListBuilder {
  constructor(spec) {
    super();

    _defineProperty(this, "spec", void 0);

    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }

  apiVersion(apiVersion) {
    return this.clone({
      options: _objectSpread(_objectSpread({}, this.spec.options || {
        filter: ''
      }), {}, {
        apiVersion
      })
    });
  }

  getApiVersion() {
    var _this$spec$options;

    return (_this$spec$options = this.spec.options) === null || _this$spec$options === void 0 ? void 0 : _this$spec$options.apiVersion;
  }

  filter(filter) {
    return this.clone({
      options: _objectSpread(_objectSpread({}, this.spec.options || {}), {}, {
        filter
      })
    });
  }

  getFilter() {
    var _this$spec$options2;

    return (_this$spec$options2 = this.spec.options) === null || _this$spec$options2 === void 0 ? void 0 : _this$spec$options2.filter;
  }

  schemaType(type) {
    var schemaTypeName = typeof type === 'string' ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }

  getSchemaType() {
    return this.spec.schemaTypeName;
  }

  params(params) {
    return this.clone({
      options: _objectSpread(_objectSpread({}, this.spec.options || {
        filter: ''
      }), {}, {
        params
      })
    });
  }

  getParams() {
    var _this$spec$options3;

    return (_this$spec$options3 = this.spec.options) === null || _this$spec$options3 === void 0 ? void 0 : _this$spec$options3.params;
  }

  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error('`defaultOrdering` must be an array of order clauses');
    }

    return this.clone({
      options: _objectSpread(_objectSpread({}, this.spec.options || {
        filter: ''
      }), {}, {
        defaultOrdering: ordering
      })
    });
  }

  getDefaultOrdering() {
    var _this$spec$options4;

    return (_this$spec$options4 = this.spec.options) === null || _this$spec$options4 === void 0 ? void 0 : _this$spec$options4.defaultOrdering;
  }

  serialize() {
    var _this$spec$options5;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };

    if (typeof this.spec.id !== 'string' || !this.spec.id) {
      throw new _SerializeError.SerializeError('`id` is required for document lists', options.path, options.index, this.spec.title).withHelpUrl(_SerializeError.HELP_URL.ID_REQUIRED);
    }

    if (!this.spec.options || !this.spec.options.filter) {
      throw new _SerializeError.SerializeError('`filter` is required for document lists', options.path, this.spec.id, this.spec.title).withHelpUrl(_SerializeError.HELP_URL.FILTER_REQUIRED);
    }

    return _objectSpread(_objectSpread({}, super.serialize(options)), {}, {
      type: 'documentList',
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || resolveDocumentChildForItem,
      options: _objectSpread(_objectSpread({}, this.spec.options), {}, {
        apiVersion: this.spec.options.apiVersion || (((_this$spec$options5 = this.spec.options) === null || _this$spec$options5 === void 0 ? void 0 : _this$spec$options5.filter) === '_type == $type' ? '2021-06-07' : '1'),
        filter: validateFilter(this.spec, options)
      })
    });
  }

  clone(withSpec) {
    var builder = new DocumentListBuilder();
    builder.spec = _objectSpread(_objectSpread({}, this.spec), withSpec || {});

    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(builder.spec);
    }

    if (!this.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }

    return builder;
  }

  getSpec() {
    return this.spec;
  }

}

exports.DocumentListBuilder = DocumentListBuilder;

function inferInitialValueTemplates(spec) {
  var schema = (0, _Schema.getDefaultSchema)();
  var schemaTypeName = spec.schemaTypeName,
      options = spec.options;

  var _ref = options || {
    filter: '',
    params: {}
  },
      filter = _ref.filter,
      params = _ref.params;

  var typeNames = schemaTypeName ? [schemaTypeName] : getTypeNamesFromFilter(filter, params);

  if (typeNames.length === 0) {
    return undefined;
  }

  var templateItems = [];
  return typeNames.reduce((items, typeName) => {
    var schemaType = schema.get(typeName);

    if (!(0, _documentActionUtils.isActionEnabled)(schemaType, 'create')) {
      return items;
    }

    return items.concat((0, _initialValueTemplates.getParameterlessTemplatesBySchemaType)(typeName).map(tpl => ({
      type: 'initialValueTemplateItem',
      id: tpl.id,
      templateId: tpl.id
    })));
  }, templateItems);
}

function inferTypeName(spec) {
  var options = spec.options;

  var _ref2 = options || {
    filter: '',
    params: {}
  },
      filter = _ref2.filter,
      params = _ref2.params;

  var typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : undefined;
}

function getTypeNamesFromFilter(filter) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var typeNames = getTypeNamesFromEqualityFilter(filter, params);

  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }

  return typeNames;
} // From _type == "movie" || _type == $otherType


function getTypeNamesFromEqualityFilter(filter) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  var matches = [];
  var match;

  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }

  return matches.map(candidate => {
    var typeName = candidate[0] === '$' ? params[candidate.slice(1)] : candidate;
    var normalized = (typeName || '').trim().replace(/^["']|["']$/g, '');
    return normalized;
  }).filter(Boolean);
} // From _type in ["dog", "cat", $otherSpecies]


function getTypeNamesFromInTypesFilter(filter) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var pattern = /\b_type\s+in\s+\[(.*?)\]/;
  var matches = filter.match(pattern);

  if (!matches) {
    return [];
  }

  return matches[1].split(/,\s*/).map(match => match.trim().replace(/^["']+|["']+$/g, '')).map(item => item[0] === '$' ? params[item.slice(1)] : item).filter(Boolean);
}