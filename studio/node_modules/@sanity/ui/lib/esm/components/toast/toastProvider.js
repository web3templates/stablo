var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = typeof require !== "undefined" ? require : (x) => {
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
import { AnimatePresence, motion } from "framer-motion";
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import styled from "styled-components";
import { Box } from "../../primitives";
import { Layer } from "../../utils";
import { Toast } from "./toast";
import { ToastContext } from "./toastContext";
const Root = styled(Layer)`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
`;
const ToastContainer = styled.div`
  box-sizing: border-box;
  position: absolute;
  right: 0;
  bottom: 0;
  max-width: 420px;
  width: 100%;
`;
let toastId = 0;
function ToastProvider(props) {
  const { children, padding = 4, paddingX, paddingY, zOffset } = props;
  const [state, setState] = useState({ toasts: [] });
  const toastsRef = useRef({});
  const push = useCallback((params) => {
    const id = params.id || String(toastId++);
    const duration = params.duration || 5e3;
    const dismiss = () => {
      var _a;
      const timeoutId = (_a = toastsRef.current[id]) == null ? void 0 : _a.timeoutId;
      setState((prevState) => {
        const idx = prevState.toasts.findIndex((t) => t.id === id);
        if (idx > -1) {
          const toasts = prevState.toasts.slice(0);
          toasts.splice(idx, 1);
          return __spreadProps(__spreadValues({}, prevState), { toasts });
        }
        return prevState;
      });
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        delete toastsRef.current[id];
      }
    };
    setState((prevState) => {
      return __spreadProps(__spreadValues({}, prevState), {
        toasts: prevState.toasts.filter((t) => t.id !== id).concat([
          {
            dismiss,
            id,
            params: __spreadProps(__spreadValues({}, params), { duration })
          }
        ])
      });
    });
    if (toastsRef.current[id]) {
      clearTimeout(toastsRef.current[id].timeoutId);
      delete toastsRef.current[id];
    }
    toastsRef.current[id] = { timeoutId: setTimeout(dismiss, duration) };
    return id;
  }, []);
  useEffect(() => () => {
    for (const { timeoutId } of Object.values(toastsRef.current)) {
      clearTimeout(timeoutId);
    }
    toastsRef.current = {};
  }, []);
  const value = useMemo(() => ({ version: 0, push }), [push]);
  return /* @__PURE__ */ React.createElement(ToastContext.Provider, {
    value
  }, children, /* @__PURE__ */ React.createElement(Root, {
    "data-ui": "ToastProvider",
    zOffset
  }, /* @__PURE__ */ React.createElement(ToastContainer, null, /* @__PURE__ */ React.createElement(Box, {
    padding,
    paddingX,
    paddingY
  }, /* @__PURE__ */ React.createElement(AnimatePresence, {
    initial: false
  }, state.toasts.map(({ dismiss, id, params }) => /* @__PURE__ */ React.createElement(motion.div, {
    animate: { opacity: 1, y: 0, scale: 1 },
    exit: { opacity: 0, scale: 0.5, transition: { duration: 0.2 } },
    initial: { opacity: 0, y: 32, scale: 0.25 },
    key: id,
    layout: "position",
    transition: { type: "spring", damping: 30, stiffness: 400 }
  }, /* @__PURE__ */ React.createElement(Toast, {
    closable: params.closable,
    description: params.description,
    onClose: dismiss,
    status: params.status,
    title: params.title
  }))))))));
}
export {
  ToastProvider
};
