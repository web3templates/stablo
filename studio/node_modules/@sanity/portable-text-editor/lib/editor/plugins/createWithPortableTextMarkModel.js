"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWithPortableTextMarkModel = createWithPortableTextMarkModel;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _debug = require("../../utils/debug");

var _ranges = require("../../utils/ranges");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var debug = (0, _debug.debugWithName)('plugin:withPortableTextMarkModel');

function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator, change$) {
  return function withPortableTextMarkModel(editor) {
    var apply = editor.apply,
        normalizeNode = editor.normalizeNode;
    var decorators = portableTextFeatures.decorators.map(t => t.value); // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks

    editor.normalizeNode = nodeEntry => {
      normalizeNode(nodeEntry);

      var _nodeEntry = _slicedToArray(nodeEntry, 2),
          node = _nodeEntry[0],
          path = _nodeEntry[1];

      var isBlock = node._type === portableTextFeatures.types.block.name;
      var isSpan = node._type === portableTextFeatures.types.span.name;

      if (isSpan) {
        if (!node.marks) {
          debug('Adding .marks to span node');

          _slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path
          });

          editor.onChange();
        }

        if (editor.operations.some(op => ['insert_node', 'insert_text', 'merge_node', 'remove_node', 'remove_text', 'set_node'].includes(op.type))) {
          mergeSpans(editor);
        }

        var _iterator = _createForOfIteratorHelper(editor.operations),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var op = _step.value;

            // Make sure markDefs are copied over when merging two blocks.
            if (op.type === 'merge_node' && op.path.length === 1 && op.properties._type === portableTextFeatures.types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
              var _Editor$node = _slate.Editor.node(editor, [op.path[0] - 1]),
                  _Editor$node2 = _slicedToArray(_Editor$node, 2),
                  targetBlock = _Editor$node2[0],
                  targetPath = _Editor$node2[1];

              debug("Copying markDefs over to merged block", op);

              if (targetBlock) {
                var oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];

                _slate.Transforms.setNodes(editor, {
                  markDefs: (0, _uniq2.default)([...oldDefs, ...op.properties.markDefs])
                }, {
                  at: targetPath,
                  voids: false
                });

                editor.onChange();
              }
            } // Make sure markDefs are copied over to new block when splitting a block.


            if (op.type === 'split_node' && op.path.length === 1 && op.properties._type === portableTextFeatures.types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor.children.length) {
              var _Editor$node3 = _slate.Editor.node(editor, [op.path[0] + 1]),
                  _Editor$node4 = _slicedToArray(_Editor$node3, 2),
                  _targetBlock = _Editor$node4[0],
                  _targetPath = _Editor$node4[1];

              debug("Copying markDefs over to split block", op);

              if (_targetBlock) {
                var _oldDefs = Array.isArray(_targetBlock.markDefs) && _targetBlock.markDefs || [];

                _slate.Transforms.setNodes(editor, {
                  markDefs: (0, _uniq2.default)([..._oldDefs, ...op.properties.markDefs])
                }, {
                  at: _targetPath,
                  voids: false
                });

                editor.onChange();
              }
            } // Make sure marks are reset, if a block is split at the end.


            if (op.type === 'split_node' && op.path.length === 2 && op.properties._type === portableTextFeatures.types.span.name && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor.children.length) {
              var _Editor$node5 = _slate.Editor.node(editor, [op.path[0] + 1, 0]),
                  _Editor$node6 = _slicedToArray(_Editor$node5, 2),
                  child = _Editor$node6[0],
                  childPath = _Editor$node6[1];

              if (child && child.text === '' && Array.isArray(child.marks) && child.marks.length > 0) {
                _slate.Transforms.setNodes(editor, {
                  marks: []
                }, {
                  at: childPath,
                  voids: false
                });

                editor.onChange();
              }
            }
          } // Remove marks if text is empty

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (Array.isArray(node.marks) && node.marks.length > 0 && node.text === '') {
          _slate.Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path,
            voids: false
          });

          editor.onChange();
        }
      } // Check consistency of markDefs


      if (isBlock && editor.operations.some(op => ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
        normalizeMarkDefs(editor);
      }
    }; // Special hook before inserting text at the end of an annotation.


    editor.apply = op => {
      if (op.type === 'insert_text') {
        var _Editor$marks, _Editor$marks$marks;

        var selection = editor.selection;

        if (selection && _slate.Range.isCollapsed(selection) && (_Editor$marks = _slate.Editor.marks(editor)) !== null && _Editor$marks !== void 0 && (_Editor$marks$marks = _Editor$marks.marks) !== null && _Editor$marks$marks !== void 0 && _Editor$marks$marks.some(mark => !decorators.includes(mark))) {
          var _ref = Array.from(_slate.Editor.nodes(editor, {
            mode: 'lowest',
            at: selection.focus,
            match: n => n._type === portableTextFeatures.types.span.name,
            voids: false
          }))[0] || [undefined],
              _ref2 = _slicedToArray(_ref, 1),
              node = _ref2[0];

          if (node && node.text && typeof node.text === 'string' && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {
            apply(op);

            _slate.Transforms.splitNodes(editor, {
              match: _slate.Text.isText,
              at: _objectSpread(_objectSpread({}, selection.focus), {}, {
                offset: selection.focus.offset
              })
            });

            var marksWithoutAnnotationMarks = (_objectSpread({}, _slate.Editor.marks(editor) || {}).marks || []).filter(mark => decorators.includes(mark));

            _slate.Transforms.setNodes(editor, {
              marks: marksWithoutAnnotationMarks
            }, {
              at: _slate.Path.next(selection.focus.path)
            });

            return;
          }
        }
      }

      apply(op);
    }; // Override built in addMark function


    editor.addMark = mark => {
      if (editor.selection) {
        if (_slate.Range.isExpanded(editor.selection)) {
          // Split if needed
          _slate.Transforms.setNodes(editor, {}, {
            match: _slate.Text.isText,
            split: true
          }); // Use new selection


          var splitTextNodes = [..._slate.Editor.nodes(editor, {
            at: editor.selection,
            match: _slate.Text.isText
          })];
          var shouldRemoveMark = (0, _flatten2.default)(splitTextNodes.map(item => item[0]).map(node => node.marks)).includes(mark);

          if (shouldRemoveMark) {
            editor.removeMark(mark);
            return;
          }

          splitTextNodes.forEach(_ref3 => {
            var _ref4 = _slicedToArray(_ref3, 2),
                node = _ref4[0],
                path = _ref4[1];

            var marks = [...(Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark), mark];

            _slate.Transforms.setNodes(editor, {
              marks
            }, {
              at: path
            });
          });
        } else {
          var existingMarks = _objectSpread({}, _slate.Editor.marks(editor) || {}).marks || [];

          var marks = _objectSpread(_objectSpread({}, _slate.Editor.marks(editor) || {}), {}, {
            marks: [...existingMarks, mark]
          });

          editor.marks = marks;
        }

        editor.onChange();
      }
    }; // Override built in removeMark function


    editor.removeMark = mark => {
      if (editor.selection) {
        if (_slate.Range.isExpanded(editor.selection)) {
          // Split if needed
          _slate.Transforms.setNodes(editor, {}, {
            match: _slate.Text.isText,
            split: true
          });

          var splitTextNodes = [..._slate.Editor.nodes(editor, {
            at: editor.selection,
            match: _slate.Text.isText
          })];
          splitTextNodes.forEach(_ref5 => {
            var _ref6 = _slicedToArray(_ref5, 2),
                node = _ref6[0],
                path = _ref6[1];

            _slate.Transforms.setNodes(editor, {
              marks: (Array.isArray(node.marks) ? node.marks : []).filter(eMark => eMark !== mark)
            }, {
              at: path
            });
          });
        } else {
          var existingMarks = _objectSpread({}, _slate.Editor.marks(editor) || {}).marks || [];

          var marks = _objectSpread(_objectSpread({}, _slate.Editor.marks(editor) || {}), {}, {
            marks: existingMarks.filter(eMark => eMark !== mark)
          });

          editor.marks = marks;
        }

        editor.onChange();
      }
    };

    editor.pteIsMarkActive = mark => {
      if (!editor.selection) {
        return false;
      }

      var existingMarks = _objectSpread({}, _slate.Editor.marks(editor) || {}).marks || [];

      if (_slate.Range.isExpanded(editor.selection)) {
        Array.from(_slate.Editor.nodes(editor, {
          match: _slate.Text.isText,
          at: editor.selection
        })).forEach(n => {
          var _ref7 = n,
              _ref8 = _slicedToArray(_ref7, 1),
              node = _ref8[0];

          existingMarks = (0, _uniq2.default)([...existingMarks, ...(node.marks || [])]);
        });
      }

      return existingMarks.includes(mark);
    }; // Custom editor function to toggle a mark


    editor.pteToggleMark = mark => {
      var isActive = editor.pteIsMarkActive(mark);

      if (isActive) {
        debug("Remove mark '".concat(mark, "'"));

        _slate.Editor.removeMark(editor, mark);
      } else {
        debug("Add mark '".concat(mark, "'"));

        _slate.Editor.addMark(editor, mark, true);
      }

      var newSelection = (0, _ranges.toPortableTextRange)(editor);

      if (newSelection) {
        // Emit a new selection here (though it might be the same).
        // This is for toolbars etc that listens to selection changes to update themselves.
        change$.next({
          type: 'selection',
          selection: newSelection
        });
      }

      editor.onChange();
    };

    return editor;
  };
  /**
   * Normalize re-marked spans in selection
   * @param {Editor} editor
   */

  function mergeSpans(editor) {
    var selection = editor.selection;

    if (selection) {
      var _iterator2 = _createForOfIteratorHelper(Array.from(_slate.Editor.nodes(editor, {
        at: _slate.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])
      })).reverse()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              node = _step2$value[0],
              path = _step2$value[1];

          var _ref9 = path.length > 1 ? _slate.Editor.node(editor, _slate.Path.parent(path)) : [undefined],
              _ref10 = _slicedToArray(_ref9, 1),
              parent = _ref10[0];

          var nextPath = [path[0], path[1] + 1];

          if (_slate.Editor.isBlock(editor, parent)) {
            var nextNode = parent.children[nextPath[1]];

            if (node._type === 'span' && nextNode && nextNode._type === 'span' && (0, _isEqual2.default)(nextNode.marks, node.marks)) {
              debug('Merging spans');

              _slate.Transforms.mergeNodes(editor, {
                at: nextPath,
                voids: true
              });

              editor.onChange();
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }
  /**
   * Normalize markDefs
   *
   * @param {Editor} editor
   */


  function normalizeMarkDefs(editor) {
    var selection = editor.selection;

    if (selection) {
      var blocks = _slate.Editor.nodes(editor, {
        at: selection,
        match: n => n._type === portableTextFeatures.types.block.name
      });

      var _iterator3 = _createForOfIteratorHelper(blocks),
          _step3;

      try {
        var _loop = function _loop() {
          var _step3$value = _slicedToArray(_step3.value, 2),
              block = _step3$value[0],
              path = _step3$value[1];

          if (Array.isArray(block.markDefs) && _slate.Element.isElement(block)) {
            var newMarkDefs = block.markDefs.filter(def => {
              return block.children.find(child => {
                return Array.isArray(child.marks) && child.marks.includes(def._key);
              });
            });

            if (!(0, _isEqual2.default)(newMarkDefs, block.markDefs)) {
              debug('Removing markDef not in use');

              _slate.Transforms.setNodes(editor, {
                markDefs: newMarkDefs
              }, {
                at: path
              });

              editor.onChange();
            }
          }
        };

        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }
}