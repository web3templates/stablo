"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PortableTextEditable = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _slate = require("slate");

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _blockTools = require("@sanity/block-tools");

var _react = _interopRequireWildcard(require("react"));

var _slateReact = require("@sanity/slate-react");

var _values = require("../utils/values");

var _copyPaste = require("../utils/copyPaste");

var _selection2 = require("../utils/selection");

var _ranges = require("../utils/ranges");

var _debug = require("../utils/debug");

var _weakMaps = require("../utils/weakMaps");

var _createWithEditableAPI = require("./plugins/createWithEditableAPI");

var _plugins = require("./plugins");

var _Leaf = require("./Leaf");

var _Element = require("./Element");

var _withPortableText = require("./withPortableText");

var _usePortableTextEditor = require("./hooks/usePortableTextEditor");

var _usePortableTextEditorValue = require("./hooks/usePortableTextEditorValue");

var _PortableTextEditor = require("./PortableTextEditor");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var debug = (0, _debug.debugWithName)('component:Editable'); // Weakmap for testing if we need to update the state value from a new value coming in from props

var VALUE_TO_SLATE_VALUE = new WeakMap();
var SELECT_TOP_DOCUMENT = {
  anchor: {
    path: [0, 0],
    offset: 0
  },
  focus: {
    path: [0, 0],
    offset: 0
  }
};

var PortableTextEditable = props => {
  var hotkeys = props.hotkeys,
      placeholderText = props.placeholderText,
      renderAnnotation = props.renderAnnotation,
      renderBlock = props.renderBlock,
      renderChild = props.renderChild,
      renderDecorator = props.renderDecorator,
      spellCheck = props.spellCheck;
  var portableTextEditor = (0, _usePortableTextEditor.usePortableTextEditor)();
  var value = (0, _usePortableTextEditorValue.usePortableTextEditorValue)();
  var change$ = portableTextEditor.change$,
      isThrottling = portableTextEditor.isThrottling,
      incomingPatches$ = portableTextEditor.incomingPatches$,
      keyGenerator = portableTextEditor.keyGenerator,
      maxBlocks = portableTextEditor.maxBlocks,
      portableTextFeatures = portableTextEditor.portableTextFeatures,
      readOnly = portableTextEditor.readOnly;
  var placeHolderBlock = (0, _react.useMemo)(() => ({
    _type: portableTextFeatures.types.block.name,
    _key: keyGenerator(),
    style: 'normal',
    markDefs: [],
    children: [{
      _type: 'span',
      _key: keyGenerator(),
      text: '',
      marks: []
    }]
  }), [portableTextFeatures.types.block.name, keyGenerator]); // React/UI-spesific plugins

  var withInsertData = (0, _react.useMemo)(() => (0, _plugins.createWithInsertData)(change$, portableTextFeatures, keyGenerator), []);
  var withHotKeys = (0, _react.useMemo)(() => (0, _plugins.createWithHotkeys)(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys), []); // Create the PortableTextEditor API

  var withEditableAPI = (0, _react.useMemo)(() => (0, _createWithEditableAPI.createWithEditableAPI)(portableTextEditor, portableTextFeatures, keyGenerator), []); // Init the Slate Editor

  var editor = (0, _react.useMemo)(() => withHotKeys(withInsertData(withEditableAPI((0, _slateReact.withReact)((0, _withPortableText.withPortableText)((0, _slate.createEditor)(), {
    portableTextFeatures: portableTextFeatures,
    keyGenerator,
    change$,
    maxBlocks,
    incomingPatches$,
    readOnly
  }))))), []); // Track editor value

  var _useState = (0, _react.useState)( // Default value
  (0, _values.toSlateValue)(getValueOrIntitialValue(value, [placeHolderBlock]), portableTextFeatures.types.block.name, _weakMaps.KEY_TO_SLATE_ELEMENT.get(editor))),
      _useState2 = _slicedToArray(_useState, 2),
      stateValue = _useState2[0],
      setStateValue = _useState2[1]; // Track selection state


  var _useState3 = (0, _react.useState)(editor.selection),
      _useState4 = _slicedToArray(_useState3, 2),
      selection = _useState4[0],
      setSelection = _useState4[1];

  var _useState5 = (0, _react.useState)(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isSelecting = _useState6[0],
      setIsSelecting = _useState6[1];

  var renderElement = (0, _react.useCallback)(eProps => {
    if ((0, _values.isEqualToEmptyEditor)(editor.children, portableTextFeatures)) {
      return /*#__PURE__*/_react.default.createElement("div", eProps.attributes, eProps.children);
    }

    return /*#__PURE__*/_react.default.createElement(_Element.Element, _extends({}, eProps, {
      keyGenerator: keyGenerator,
      portableTextFeatures: portableTextFeatures,
      readOnly: readOnly,
      renderBlock: renderBlock,
      renderChild: renderChild
    }));
  }, [value, renderChild, renderBlock]);
  var renderLeaf = (0, _react.useCallback)(lProps => {
    if ((0, _values.isEqualToEmptyEditor)(editor.children, portableTextFeatures)) {
      return /*#__PURE__*/_react.default.createElement("span", lProps.attributes, lProps.children);
    }

    return /*#__PURE__*/_react.default.createElement(_Leaf.Leaf, _extends({}, lProps, {
      keyGenerator: keyGenerator,
      portableTextFeatures: portableTextFeatures,
      renderAnnotation: renderAnnotation,
      renderChild: renderChild,
      renderDecorator: renderDecorator,
      readOnly: readOnly
    }));
  }, [value, renderChild, renderDecorator, renderAnnotation]);

  var handleChange = val => {
    if (val !== stateValue) {
      setStateValue(val);
    }

    if (editor.selection !== selection) {
      setSelection(editor.selection);
    }
  }; // // Test Slate decorations. Highlight the word 'w00t'
  // // TODO: remove this and make something useful.
  // const woot = 'w00t'
  // const decorate = useCallback(
  //   ([node, path]) => {
  //     const ranges: Range[] = []
  //     if (woot && Text.isText(node)) {
  //       const {text} = node
  //       const parts = text.split(woot)
  //       let offset = 0
  //       parts.forEach((part, i) => {
  //         if (i !== 0) {
  //           ranges.push({
  //             anchor: {path, offset: offset - woot.length},
  //             focus: {path, offset},
  //             __highlight: true
  //           })
  //         }
  //         offset = offset + part.length + woot.length
  //       })
  //     }
  //     return ranges
  //   },
  //   [woot]
  // )


  var setValueFromProps = () => {
    var fromMap = VALUE_TO_SLATE_VALUE.get(value || []);

    if (fromMap === stateValue) {
      debug('Value in sync, not updating value from props');
    } else {
      debug('Setting value from props');
      var slateValueFromProps = (0, _values.toSlateValue)(value, portableTextFeatures.types.block.name, _weakMaps.KEY_TO_SLATE_ELEMENT.get(editor));
      setStateValue(slateValueFromProps);
      VALUE_TO_SLATE_VALUE.set(value || [], slateValueFromProps);
      change$.next({
        type: 'value',
        value
      });
    }
  };

  (0, _react.useEffect)(() => {
    _weakMaps.KEY_TO_SLATE_ELEMENT.set(editor, {});

    _weakMaps.KEY_TO_VALUE_ELEMENT.set(editor, {});

    return () => {
      _weakMaps.KEY_TO_SLATE_ELEMENT.delete(editor);

      _weakMaps.KEY_TO_VALUE_ELEMENT.delete(editor);
    };
  }, [editor]); // Restore value from props

  (0, _react.useEffect)(() => {
    if (isThrottling) {
      debug('Not setting value from props (throttling)');
      return;
    }

    if (isSelecting) {
      debug('Not setting value from props (is selecting)');
      return;
    }

    setValueFromProps();
  }, [value, isSelecting]); // Restore selection from props

  (0, _react.useEffect)(() => {
    var pSelection = props.selection;

    if (pSelection && !isThrottling && !(0, _isEqual2.default)(pSelection, (0, _ranges.toPortableTextRange)(editor))) {
      debug('Selection from props', pSelection);
      var normalizedSelection = (0, _selection2.normalizeSelection)(pSelection, value);

      if (normalizedSelection !== null) {
        debug('Normalized selection from props', normalizedSelection);
        var slateRange = (0, _ranges.toSlateRange)(normalizedSelection, editor);
        setSelection(slateRange);
      } else if (stateValue) {
        debug('Selecting top document');
        setSelection(SELECT_TOP_DOCUMENT);
      }
    }
  }, [props.selection]); // Handle copy in the editor

  var handleCopy = event => {
    var onCopy = props.onCopy;

    if (onCopy) {
      var result = onCopy(event); // CopyFn may return something to avoid doing default stuff

      if (result !== undefined) {
        event.preventDefault();
        return;
      }
    }

    if ((0, _copyPaste.hasEditableTarget)(editor, event.target)) {
      // Set Portable Text on the clipboard
      (0, _copyPaste.setFragmentData)(event.clipboardData, editor, portableTextFeatures);
    }
  }; // Handle pasting in the editor


  var handlePaste = event => {
    event.persist(); // Keep the event through the plugin chain after calling next()

    var onPaste = props.onPaste;

    var _selection = _PortableTextEditor.PortableTextEditor.getSelection(portableTextEditor);

    var type = portableTextFeatures.types.portableText;

    if (!_selection) {
      return;
    }

    if (onPaste) {
      var resolveOnPasteResultOrError = () => {
        try {
          return onPaste({
            event,
            value,
            path: _selection.focus.path,
            type
          });
        } catch (error) {
          return error;
        }
      }; // Resolve it as promise (can be either async promise or sync return value)


      var resolved = Promise.resolve(resolveOnPasteResultOrError());
      resolved.then(result => {
        debug('Custom paste function from client resolved', result);
        change$.next({
          type: 'loading',
          isLoading: true
        });

        if (!result) {
          return;
        }

        if (result instanceof Error) {
          throw result;
        }

        if (result && result.insert) {
          event.preventDefault(); // Stop the chain

          var allowedDecorators = portableTextFeatures.decorators.map(item => item.value);
          var blocksToInsertNormalized = result.insert.map(block => (0, _blockTools.normalizeBlock)(block, {
            allowedDecorators
          }));
          var dataTransfer = new DataTransfer();
          var stringToEncode = JSON.stringify((0, _values.toSlateValue)(blocksToInsertNormalized, portableTextFeatures.types.block.name));
          var encoded = window.btoa(encodeURIComponent(stringToEncode));
          dataTransfer.setData('application/x-slate-fragment', encoded);
          editor.insertData(dataTransfer);
          change$.next({
            type: 'loading',
            isLoading: false
          });
          editor.onChange();
          return;
        }

        console.warn('Your onPaste function returned something unexpected:', result);
      }).catch(error => {
        change$.next({
          type: 'loading',
          isLoading: false
        });
        console.error(error); // eslint-disable-line no-console

        return error;
      });
    }
  }; // There's a bug in Slate atm regarding void nodes not being deleted. Seems related
  // to 'hanging: true' and 'voids: false'. 2020/05/26


  var handleCut = event => {
    event.preventDefault();
    event.stopPropagation();

    if (editor.selection) {
      _slateReact.ReactEditor.setFragmentData(editor, event.clipboardData);

      _slate.Transforms.delete(editor, {
        at: editor.selection,
        voids: false,
        hanging: true
      });

      _slate.Transforms.collapse(editor);

      editor.onChange();
    }

    return editor;
  }; // Set initial selection from props


  (0, _react.useEffect)(() => {
    if (props.selection) {
      _PortableTextEditor.PortableTextEditor.select(portableTextEditor, props.selection);
    }
  }, []); // Emit selection after a selection is made

  var emitSelection = () => {
    try {
      var newSelection = (0, _ranges.toPortableTextRange)(editor); // debug('Emitting new selection', JSON.stringify(newSelection))

      change$.next({
        type: 'selection',
        selection: newSelection
      });
    } catch (err) {
      change$.next({
        type: 'selection',
        selection: null
      });
    }
  };

  var handleSelect = () => {
    if (isThrottling) {
      return;
    }

    emitSelection();
  };

  (0, _react.useEffect)(() => {
    if (isThrottling) {
      return;
    }

    emitSelection();
  }, [isThrottling]);
  (0, _react.useEffect)(() => {
    emitSelection();
  }, [selection]); // Make sure that when the user is actively selecting something, we don't update the editor or selections will be broken

  var _isSelecting = false;

  var onSelectStart = event => {
    if (_slateReact.ReactEditor.hasDOMNode(editor, event.target)) {
      debug('Start selecting');
      _isSelecting = true;
      setTimeout(() => setIsSelecting(true));
    }
  };

  var onSelectEnd = () => {
    if (_isSelecting) {
      debug('Done selecting');
      setTimeout(() => setIsSelecting(false));
    }
  };

  var isSelectKeys = event => (0, _isHotkey.default)('shift+down', event) || (0, _isHotkey.default)('shift+up', event) || (0, _isHotkey.default)('shift+left', event) || (0, _isHotkey.default)('shift+right', event) || (0, _isHotkey.default)('shift+end', event) || (0, _isHotkey.default)('shift+home', event) || (0, _isHotkey.default)('shift+pageDown', event) || (0, _isHotkey.default)('shift+pageUp', event);

  var isSelectingWithKeys = false;

  var onSelectStartWithKeys = event => {
    if (isSelectKeys(event)) {
      isSelectingWithKeys = true;
      onSelectStart(event);
    }
  };

  var onSelectEndWithKeys = event => {
    if (isSelectingWithKeys && event.key === 'Shift') {
      onSelectEnd();
      isSelectingWithKeys = false;
    }
  };

  (0, _react.useEffect)(() => {
    document.addEventListener('keydown', onSelectStartWithKeys, false);
    document.addEventListener('keyup', onSelectEndWithKeys, false);
    document.addEventListener('mousedown', onSelectStart, false);
    document.addEventListener('mouseup', onSelectEnd, false);
    document.addEventListener('dragend', onSelectEnd, false);
    return () => {
      document.removeEventListener('keydown', onSelectStartWithKeys, false);
      document.removeEventListener('keyup', onSelectEndWithKeys, false);
      document.removeEventListener('mousedown', onSelectStart, false);
      document.removeEventListener('mouseup', onSelectEnd, false);
      document.removeEventListener('dragend', onSelectEnd, false);
    };
  }, []);

  var handleOnFocus = () => {
    change$.next({
      type: 'focus'
    });
  };

  var handleOnBlur = () => {
    change$.next({
      type: 'blur'
    });
  };

  var handleOnBeforeInput = event => {
    if (props.onBeforeInput) {
      props.onBeforeInput(event);
    }
  };

  var handleKeyDown = editor.pteWithHotKeys; // The editor

  var slateEditable = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_slateReact.Slate, {
    onChange: handleChange,
    editor: editor,
    selection: selection,
    value: getValueOrIntitialValue(stateValue, [placeHolderBlock])
  }, /*#__PURE__*/_react.default.createElement(_slateReact.Editable, {
    autoFocus: false,
    className: 'pt-editable' // decorate={decorate}
    ,
    onDOMBeforeInput: handleOnBeforeInput,
    onBlur: handleOnBlur,
    onCopy: handleCopy,
    onCut: handleCut,
    onFocus: handleOnFocus,
    onKeyDown: handleKeyDown,
    onPaste: handlePaste,
    onSelect: handleSelect,
    placeholder: placeholderText,
    readOnly: readOnly,
    renderElement: renderElement,
    renderLeaf: renderLeaf,
    spellCheck: spellCheck
  })), [placeholderText, readOnly, spellCheck, stateValue, selection, renderElement]);

  if (!portableTextEditor) {
    return null;
  }

  return slateEditable;
};

exports.PortableTextEditable = PortableTextEditable;

function getValueOrIntitialValue(value, initialValue) {
  if (Array.isArray(value) && value.length > 0) {
    return value;
  }

  return initialValue;
}