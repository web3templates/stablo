"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PortableTextEditor = exports.defaultKeyGenerator = void 0;

var _react = _interopRequireDefault(require("react"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _content = require("@sanity/util/content");

var _schema = require("../utils/schema");

var _getPortableTextFeatures = require("../utils/getPortableTextFeatures");

var _patches = require("../utils/patches");

var _validateValue = require("../utils/validateValue");

var _debug = require("../utils/debug");

var _usePortableTextEditor = require("./hooks/usePortableTextEditor");

var _usePortableTextEditorSelection = require("./hooks/usePortableTextEditorSelection");

var _usePortableTextEditorValue = require("./hooks/usePortableTextEditorValue");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultKeyGenerator = () => (0, _content.randomKey)(12);

exports.defaultKeyGenerator = defaultKeyGenerator;
var debug = (0, _debug.debugWithName)('component:PortableTextEditor');

// The PT editor's public API
class PortableTextEditor extends _react.default.Component {
  constructor(props) {
    super(props); // Test if we have a compiled schema type, if not, conveniently compile it

    _defineProperty(this, "changeSubscription", void 0);

    _defineProperty(this, "pendingPatches", []);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "portableTextFeatures", void 0);

    _defineProperty(this, "change$", new _rxjs.Subject());

    _defineProperty(this, "isThrottling", false);

    _defineProperty(this, "editable", void 0);

    _defineProperty(this, "keyGenerator", void 0);

    _defineProperty(this, "maxBlocks", void 0);

    _defineProperty(this, "readOnly", void 0);

    _defineProperty(this, "incomingPatches$", void 0);

    _defineProperty(this, "setEditable", editable => {
      this.editable = _objectSpread(_objectSpread({}, this.editable), editable);
      this.change$.next({
        type: 'ready'
      });
    });

    _defineProperty(this, "flush", () => {
      var onChange = this.props.onChange;
      var finalPatches = (0, _patches.compactPatches)(this.pendingPatches);

      if (finalPatches.length > 0) {
        onChange({
          type: 'mutation',
          patches: finalPatches
        });
      }

      this.pendingPatches = [];
    });

    _defineProperty(this, "onEditorChange", next => {
      var onChange = this.props.onChange;

      switch (next.type) {
        case 'mutation':
          if (this.isThrottling) {
            this.pendingPatches = [...this.pendingPatches, ...next.patches];
          } else {
            this.flush();
          }

          break;

        case 'throttle':
          if (next.throttle !== this.isThrottling) {
            onChange(next);
          }

          if (next.throttle) {
            this.isThrottling = true;
          } else {
            this.isThrottling = false;

            if (this.pendingPatches.length > 0) {
              this.flush();
            }
          }

          break;

        case 'selection':
          this.setState({
            selection: next.selection
          });
          onChange(next);
          break;

        case 'undo':
        case 'redo':
          this.flush();
          onChange(next);
          break;

        default:
          onChange(next);
      }
    });

    this.type = props.type.hasOwnProperty('jsonType') ? props.type : (0, _schema.compileType)(props.type); // Indicate that we are loading

    this.change$.next({
      type: 'loading',
      isLoading: true
    }); // Get the block types feature set (lookup table)

    this.portableTextFeatures = (0, _getPortableTextFeatures.getPortableTextFeatures)(this.type); // Subscribe to (distinct) changes

    this.changeSubscription = this.change$.pipe((0, _operators.distinctUntilChanged)()).subscribe(this.onEditorChange); // Setup keyGenerator (either from props, or default)

    this.keyGenerator = props.keyGenerator || defaultKeyGenerator; // Validate the Portable Text value

    var state = {
      selection: null,
      invalidValueResolution: null
    };
    var validation = (0, _validateValue.validateValue)(props.value, this.portableTextFeatures, this.keyGenerator);

    if (props.value && !validation.valid) {
      this.change$.next({
        type: 'loading',
        isLoading: false
      });
      this.change$.next({
        type: 'invalidValue',
        resolution: validation.resolution,
        value: props.value
      });
      state = _objectSpread(_objectSpread({}, state), {}, {
        invalidValueResolution: validation.resolution
      });
    }

    this.incomingPatches$ = props.incomingPatches$;
    this.maxBlocks = typeof props.maxBlocks === 'undefined' ? undefined : parseInt(props.maxBlocks.toString(), 10) || undefined;
    this.readOnly = props.readOnly || false;
    this.state = state;
  }

  componentWillUnmount() {
    this.flush();
    this.changeSubscription.unsubscribe();
  }

  componentDidUpdate(prevProps) {
    this.readOnly = this.props.readOnly || false; // Validate again if value length has changed

    if (this.props.value && (prevProps.value || []).length !== this.props.value.length) {
      debug('Validating');
      var validation = (0, _validateValue.validateValue)(this.props.value, this.portableTextFeatures, this.keyGenerator);

      if (this.props.value && !validation.valid) {
        this.change$.next({
          type: 'invalidValue',
          resolution: validation.resolution,
          value: this.props.value
        }); // eslint-disable-next-line react/no-did-update-set-state

        this.setState({
          invalidValueResolution: validation.resolution
        });
      }
    }
  }

  render() {
    if (this.state.invalidValueResolution) {
      return this.state.invalidValueResolution.description;
    }

    return /*#__PURE__*/_react.default.createElement(_usePortableTextEditor.PortableTextEditorContext.Provider, {
      value: this
    }, /*#__PURE__*/_react.default.createElement(_usePortableTextEditorValue.PortableTextEditorValueContext.Provider, {
      value: this.props.value
    }, /*#__PURE__*/_react.default.createElement(_usePortableTextEditorSelection.PortableTextEditorSelectionContext.Provider, {
      value: this.state.selection
    }, this.props.children)));
  }

}

exports.PortableTextEditor = PortableTextEditor;

_defineProperty(PortableTextEditor, "activeAnnotations", editor => {
  return editor && editor.editable ? editor.editable.activeAnnotations() : [];
});

_defineProperty(PortableTextEditor, "addAnnotation", (editor, type, value) => {
  var _editor$editable;

  return (_editor$editable = editor.editable) === null || _editor$editable === void 0 ? void 0 : _editor$editable.addAnnotation(type, value);
});

_defineProperty(PortableTextEditor, "blur", editor => {
  var _editor$editable2;

  debug('Host blurred');
  (_editor$editable2 = editor.editable) === null || _editor$editable2 === void 0 ? void 0 : _editor$editable2.blur();
});

_defineProperty(PortableTextEditor, "delete", (editor, selection, options) => {
  var _editor$editable3;

  return (_editor$editable3 = editor.editable) === null || _editor$editable3 === void 0 ? void 0 : _editor$editable3.delete(selection, options);
});

_defineProperty(PortableTextEditor, "findDOMNode", (editor, element) => {
  var _editor$editable4;

  return (_editor$editable4 = editor.editable) === null || _editor$editable4 === void 0 ? void 0 : _editor$editable4.findDOMNode(element);
});

_defineProperty(PortableTextEditor, "findByPath", (editor, path) => {
  var _editor$editable5;

  return (_editor$editable5 = editor.editable) === null || _editor$editable5 === void 0 ? void 0 : _editor$editable5.findByPath(path);
});

_defineProperty(PortableTextEditor, "focus", editor => {
  var _editor$editable6;

  debug('Host requesting focus');
  (_editor$editable6 = editor.editable) === null || _editor$editable6 === void 0 ? void 0 : _editor$editable6.focus();
});

_defineProperty(PortableTextEditor, "focusBlock", editor => {
  var _editor$editable7;

  return (_editor$editable7 = editor.editable) === null || _editor$editable7 === void 0 ? void 0 : _editor$editable7.focusBlock();
});

_defineProperty(PortableTextEditor, "focusChild", editor => {
  var _editor$editable8;

  return (_editor$editable8 = editor.editable) === null || _editor$editable8 === void 0 ? void 0 : _editor$editable8.focusChild();
});

_defineProperty(PortableTextEditor, "getPortableTextFeatures", editor => {
  return editor.portableTextFeatures;
});

_defineProperty(PortableTextEditor, "getSelection", editor => {
  var _editor$editable9;

  return (_editor$editable9 = editor.editable) === null || _editor$editable9 === void 0 ? void 0 : _editor$editable9.getSelection();
});

_defineProperty(PortableTextEditor, "getValue", editor => {
  var _editor$editable10;

  return (_editor$editable10 = editor.editable) === null || _editor$editable10 === void 0 ? void 0 : _editor$editable10.getValue();
});

_defineProperty(PortableTextEditor, "hasBlockStyle", (editor, blockStyle) => {
  var _editor$editable11;

  return (_editor$editable11 = editor.editable) === null || _editor$editable11 === void 0 ? void 0 : _editor$editable11.hasBlockStyle(blockStyle);
});

_defineProperty(PortableTextEditor, "hasListStyle", (editor, listStyle) => {
  var _editor$editable12;

  return (_editor$editable12 = editor.editable) === null || _editor$editable12 === void 0 ? void 0 : _editor$editable12.hasListStyle(listStyle);
});

_defineProperty(PortableTextEditor, "isCollapsedSelection", editor => {
  var _editor$editable13;

  return (_editor$editable13 = editor.editable) === null || _editor$editable13 === void 0 ? void 0 : _editor$editable13.isCollapsedSelection();
});

_defineProperty(PortableTextEditor, "isExpandedSelection", editor => {
  var _editor$editable14;

  return (_editor$editable14 = editor.editable) === null || _editor$editable14 === void 0 ? void 0 : _editor$editable14.isExpandedSelection();
});

_defineProperty(PortableTextEditor, "isMarkActive", (editor, mark) => {
  var _editor$editable15;

  return (_editor$editable15 = editor.editable) === null || _editor$editable15 === void 0 ? void 0 : _editor$editable15.isMarkActive(mark);
});

_defineProperty(PortableTextEditor, "insertChild", (editor, type, value) => {
  var _editor$editable16;

  debug("Host inserting child");
  return (_editor$editable16 = editor.editable) === null || _editor$editable16 === void 0 ? void 0 : _editor$editable16.insertChild(type, value);
});

_defineProperty(PortableTextEditor, "insertBlock", (editor, type, value) => {
  var _editor$editable17;

  return (_editor$editable17 = editor.editable) === null || _editor$editable17 === void 0 ? void 0 : _editor$editable17.insertBlock(type, value);
});

_defineProperty(PortableTextEditor, "isVoid", (editor, element) => {
  var _editor$editable18;

  return (_editor$editable18 = editor.editable) === null || _editor$editable18 === void 0 ? void 0 : _editor$editable18.isVoid(element);
});

_defineProperty(PortableTextEditor, "marks", editor => {
  var _editor$editable19;

  return (_editor$editable19 = editor.editable) === null || _editor$editable19 === void 0 ? void 0 : _editor$editable19.marks();
});

_defineProperty(PortableTextEditor, "select", (editor, selection) => {
  var _editor$editable20;

  debug("Host setting selection", selection);
  (_editor$editable20 = editor.editable) === null || _editor$editable20 === void 0 ? void 0 : _editor$editable20.select(selection);
});

_defineProperty(PortableTextEditor, "removeAnnotation", (editor, type) => {
  var _editor$editable21;

  return (_editor$editable21 = editor.editable) === null || _editor$editable21 === void 0 ? void 0 : _editor$editable21.removeAnnotation(type);
});

_defineProperty(PortableTextEditor, "toggleBlockStyle", (editor, blockStyle) => {
  var _editor$editable22;

  debug("Host is toggling block style");
  return (_editor$editable22 = editor.editable) === null || _editor$editable22 === void 0 ? void 0 : _editor$editable22.toggleBlockStyle(blockStyle);
});

_defineProperty(PortableTextEditor, "toggleList", (editor, listStyle) => {
  var _editor$editable23;

  return (_editor$editable23 = editor.editable) === null || _editor$editable23 === void 0 ? void 0 : _editor$editable23.toggleList(listStyle);
});

_defineProperty(PortableTextEditor, "toggleMark", (editor, mark) => {
  var _editor$editable24;

  debug("Host toggling mark", mark);
  (_editor$editable24 = editor.editable) === null || _editor$editable24 === void 0 ? void 0 : _editor$editable24.toggleMark(mark);
});